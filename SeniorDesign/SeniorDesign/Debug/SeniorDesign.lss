
SeniorDesign.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000061a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000006a  00800060  0000061a  000006ae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000009c  008000ca  008000ca  00000718  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000718  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000748  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000148  00000000  00000000  00000784  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000021ad  00000000  00000000  000008cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000bc5  00000000  00000000  00002a79  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000a32  00000000  00000000  0000363e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002c4  00000000  00000000  00004070  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000712  00000000  00000000  00004334  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000755  00000000  00000000  00004a46  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000f8  00000000  00000000  0000519b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 97 02 	jmp	0x52e	; 0x52e <__vector_11>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ea e1       	ldi	r30, 0x1A	; 26
  68:	f6 e0       	ldi	r31, 0x06	; 6
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	aa 3c       	cpi	r26, 0xCA	; 202
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	21 e0       	ldi	r18, 0x01	; 1
  78:	aa ec       	ldi	r26, 0xCA	; 202
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a6 36       	cpi	r26, 0x66	; 102
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 e2 02 	call	0x5c4	; 0x5c4 <main>
  8a:	0c 94 0b 03 	jmp	0x616	; 0x616 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <init_buzzer>:
////////////////////////////////////////////////////////////////////////////////////////////////////
//											Functions											  //
////////////////////////////////////////////////////////////////////////////////////////////////////
void init_buzzer(){	
	// Initialize Buzzer
	DDRD |= (1 << BUZZER_PIN);			// Set buzzer pin (PD4) direction
  92:	8c 9a       	sbi	0x11, 4	; 17
	PORTD &= ~(1 << BUZZER_PIN);		// Clear buzzer output
  94:	94 98       	cbi	0x12, 4	; 18
	TCCR1B = (1 << WGM12)|(1 << CS11);	// Enable "CTC" mode and set prescaler = 64	 	
  96:	8a e0       	ldi	r24, 0x0A	; 10
  98:	8e bd       	out	0x2e, r24	; 46
  9a:	08 95       	ret

0000009c <EEPROM_enable>:
	
	//Enable writes to EEPROM:
	EECR |= (1 << EEMWE);
	
	//Trigger the write-enable strobe:
	EECR |= (1 << EEWE);
  9c:	84 e0       	ldi	r24, 0x04	; 4
  9e:	8c bb       	out	0x1c, r24	; 28
  a0:	1f ba       	out	0x1f, r1	; 31
  a2:	1e ba       	out	0x1e, r1	; 30
  a4:	08 95       	ret

000000a6 <EEPROM_read>:
}
////////////////////////////////////////////////////////////////////////////////////////////////////
uint8_t EEPROM_read(uint16_t address){
	
	//Wait for previous write-enable strobe to null out:
	while(EECR & (1 << EEWE));
  a6:	e1 99       	sbic	0x1c, 1	; 28
  a8:	fe cf       	rjmp	.-4      	; 0xa6 <EEPROM_read>
	
	//Load the address:
	EEARH = (address >> 8);
  aa:	9f bb       	out	0x1f, r25	; 31
	EEARL = (address) & 0xFF;
  ac:	8e bb       	out	0x1e, r24	; 30
	
	//Read in the data by strobing:
	EECR |= (1 << EERE);
  ae:	e0 9a       	sbi	0x1c, 0	; 28
	
	//Return the contents of the data register:
	return EEDR;
  b0:	8d b3       	in	r24, 0x1d	; 29
}
  b2:	08 95       	ret

000000b4 <EEPROM_recovery>:
void EEPROM_recovery(void){
	
	//Clear out erroneous data from powerdown:

	//Fetch all of the data stored in the EEPROM space, and return it to its space in memory:
	NV_SYSTEM_STATUS_0 = EEPROM_read(EEPROM_SYSTEM_STATUS_0);
  b4:	82 e0       	ldi	r24, 0x02	; 2
  b6:	90 e0       	ldi	r25, 0x00	; 0
  b8:	0e 94 53 00 	call	0xa6	; 0xa6 <EEPROM_read>
  bc:	80 93 cf 00 	sts	0x00CF, r24	; 0x8000cf <NV_SYSTEM_STATUS_0>
	NV_SYSTEM_STATUS_1 = EEPROM_read(EEPROM_SYSTEM_STATUS_1);
  c0:	83 e0       	ldi	r24, 0x03	; 3
  c2:	90 e0       	ldi	r25, 0x00	; 0
  c4:	0e 94 53 00 	call	0xa6	; 0xa6 <EEPROM_read>
  c8:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <NV_SYSTEM_STATUS_1>
	NV_USER_PREFERENCES_0 = EEPROM_read(EEPROM_USER_PREF_0);
  cc:	80 e0       	ldi	r24, 0x00	; 0
  ce:	90 e0       	ldi	r25, 0x00	; 0
  d0:	0e 94 53 00 	call	0xa6	; 0xa6 <EEPROM_read>
  d4:	80 93 cd 00 	sts	0x00CD, r24	; 0x8000cd <NV_USER_PREFERENCES_0>
	NV_USER_PREFERENCES_1 = EEPROM_read(EEPROM_USER_PREF_1);
  d8:	81 e0       	ldi	r24, 0x01	; 1
  da:	90 e0       	ldi	r25, 0x00	; 0
  dc:	0e 94 53 00 	call	0xa6	; 0xa6 <EEPROM_read>
  e0:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <NV_USER_PREFERENCES_1>
  e4:	08 95       	ret

000000e6 <GPS_init_USART>:
*/
void GPS_init_USART(uint16_t UBRR){
	
	//Set baud rate for 9600 bits per second:
	// [TYPICAL PARAMETER: 103 @ 16MHz system clock]
	UBRRH = (unsigned char)(UBRR >> 8);
  e6:	90 bd       	out	0x20, r25	; 32
	UBRRL = (unsigned char)UBRR;
  e8:	89 b9       	out	0x09, r24	; 9
	
	//Enable the transmitter and receiver bits:
	UCSRB = (1 << RXEN)|(1 << TXEN);
  ea:	88 e1       	ldi	r24, 0x18	; 24
  ec:	8a b9       	out	0x0a, r24	; 10
	
	//Set data frame format to accept 1 byte per frame, with 1 stop bit:
	UCSRC = (0 << UMSEL)|(1 << UCSZ1)|(1 << UCSZ0)|(0 << USBS);
  ee:	86 e0       	ldi	r24, 0x06	; 6
  f0:	80 bd       	out	0x20, r24	; 32
  f2:	08 95       	ret

000000f4 <GPS_disable_stream>:
	
*/
void GPS_disable_stream(void){
	
	//Clear receiver-interrupt enable bit, while maintaining register contents:
	UCSRB = UCSRB & (!(1 << RXCIE));
  f4:	8a b1       	in	r24, 0x0a	; 10
  f6:	1a b8       	out	0x0a, r1	; 10
  f8:	08 95       	ret

000000fa <GPS_send_byte>:
	
*/
void GPS_send_byte(unsigned char data){
	
	//Wait for the system to be ready to transmit more data:
	while(!(UCSRA & (1 << UDRE)));
  fa:	5d 9b       	sbis	0x0b, 5	; 11
  fc:	fe cf       	rjmp	.-4      	; 0xfa <GPS_send_byte>
	
	//Load byte into the transmitter:
	UDR = data;
  fe:	8c b9       	out	0x0c, r24	; 12
 100:	08 95       	ret

00000102 <GPS_configure_firmware>:
					2.	GPS_init_USART(9600);
					3.	GPS_configure_firmware();
					4.	GPS_enable_stream();
	
*/
void GPS_configure_firmware(void){
 102:	0f 93       	push	r16
 104:	1f 93       	push	r17
 106:	cf 93       	push	r28
 108:	df 93       	push	r29
 10a:	c8 e8       	ldi	r28, 0x88	; 136
 10c:	d0 e0       	ldi	r29, 0x00	; 0
 10e:	08 e9       	ldi	r16, 0x98	; 152
 110:	10 e0       	ldi	r17, 0x00	; 0

		//1. Configure baud rate
		for(int i = 0; i < 16; i++){
			GPS_send_byte(firmware_BAUD[i]);
 112:	89 91       	ld	r24, Y+
 114:	0e 94 7d 00 	call	0xfa	; 0xfa <GPS_send_byte>
	
*/
void GPS_configure_firmware(void){

		//1. Configure baud rate
		for(int i = 0; i < 16; i++){
 118:	0c 17       	cp	r16, r28
 11a:	1d 07       	cpc	r17, r29
 11c:	d1 f7       	brne	.-12     	; 0x112 <GPS_configure_firmware+0x10>
 11e:	c0 e7       	ldi	r28, 0x70	; 112
 120:	d0 e0       	ldi	r29, 0x00	; 0
 122:	08 e8       	ldi	r16, 0x88	; 136
 124:	10 e0       	ldi	r17, 0x00	; 0
			GPS_send_byte(firmware_BAUD[i]);
		}
		//2. Set update rate
		for(int i = 0; i < 24; i++){
			GPS_send_byte(firmware_HZ[i]);
 126:	89 91       	ld	r24, Y+
 128:	0e 94 7d 00 	call	0xfa	; 0xfa <GPS_send_byte>
		//1. Configure baud rate
		for(int i = 0; i < 16; i++){
			GPS_send_byte(firmware_BAUD[i]);
		}
		//2. Set update rate
		for(int i = 0; i < 24; i++){
 12c:	0c 17       	cp	r16, r28
 12e:	1d 07       	cpc	r17, r29
 130:	d1 f7       	brne	.-12     	; 0x126 <GPS_configure_firmware+0x24>
 132:	c0 e6       	ldi	r28, 0x60	; 96
 134:	d0 e0       	ldi	r29, 0x00	; 0
 136:	00 e7       	ldi	r16, 0x70	; 112
 138:	10 e0       	ldi	r17, 0x00	; 0
			GPS_send_byte(firmware_HZ[i]);
		}
		//3. Set fix rate
		for(int i = 0; i < 16; i++){
			GPS_send_byte(firmware_update_rate[i]);
 13a:	89 91       	ld	r24, Y+
 13c:	0e 94 7d 00 	call	0xfa	; 0xfa <GPS_send_byte>
		//2. Set update rate
		for(int i = 0; i < 24; i++){
			GPS_send_byte(firmware_HZ[i]);
		}
		//3. Set fix rate
		for(int i = 0; i < 16; i++){
 140:	0c 17       	cp	r16, r28
 142:	1d 07       	cpc	r17, r29
 144:	d1 f7       	brne	.-12     	; 0x13a <GPS_configure_firmware+0x38>
 146:	c8 e9       	ldi	r28, 0x98	; 152
 148:	d0 e0       	ldi	r29, 0x00	; 0
 14a:	09 ec       	ldi	r16, 0xC9	; 201
 14c:	10 e0       	ldi	r17, 0x00	; 0
			GPS_send_byte(firmware_update_rate[i]);
		}
		//4. Set RMC enabled
		for(int i = 0; i < 49; i++){
			GPS_send_byte(firmware_RMC[i]);
 14e:	89 91       	ld	r24, Y+
 150:	0e 94 7d 00 	call	0xfa	; 0xfa <GPS_send_byte>
		//3. Set fix rate
		for(int i = 0; i < 16; i++){
			GPS_send_byte(firmware_update_rate[i]);
		}
		//4. Set RMC enabled
		for(int i = 0; i < 49; i++){
 154:	0c 17       	cp	r16, r28
 156:	1d 07       	cpc	r17, r29
 158:	d1 f7       	brne	.-12     	; 0x14e <GPS_configure_firmware+0x4c>
			GPS_send_byte(firmware_RMC[i]);
		}
	
	
}
 15a:	df 91       	pop	r29
 15c:	cf 91       	pop	r28
 15e:	1f 91       	pop	r17
 160:	0f 91       	pop	r16
 162:	08 95       	ret

00000164 <GPS_receive_byte>:
	
*/
char GPS_receive_byte(void){
	
	//Check to see if data has been received:
	while(!(UCSRA & (1 << RXC)));
 164:	5f 9b       	sbis	0x0b, 7	; 11
 166:	fe cf       	rjmp	.-4      	; 0x164 <GPS_receive_byte>
	
	//Return the data to where it is desired:
	return UDR;
 168:	8c b1       	in	r24, 0x0c	; 12
	
}
 16a:	08 95       	ret

0000016c <GPS_flush_buffer>:
	
	DESCRIPTION:	Systematically clears out the data contained in the USART receive buffer, 
					then sets the value of the head pointer to 0;
	
*/
void GPS_flush_buffer(void){
 16c:	e0 ed       	ldi	r30, 0xD0	; 208
 16e:	f0 e0       	ldi	r31, 0x00	; 0
 170:	88 e4       	ldi	r24, 0x48	; 72
 172:	91 e0       	ldi	r25, 0x01	; 1
	
	//Clear out data
	for(int i = 0; i < 120; i++){
		GPS_BUFFER[i] = 0;
 174:	11 92       	st	Z+, r1
	
*/
void GPS_flush_buffer(void){
	
	//Clear out data
	for(int i = 0; i < 120; i++){
 176:	e8 17       	cp	r30, r24
 178:	f9 07       	cpc	r31, r25
 17a:	e1 f7       	brne	.-8      	; 0x174 <GPS_flush_buffer+0x8>
		GPS_BUFFER[i] = 0;
	}
	
	//Set pointer to zero:
	GPS_BUFFER_INDEX = 0;				//Buffer is at start position.
 17c:	10 92 cb 00 	sts	0x00CB, r1	; 0x8000cb <GPS_BUFFER_INDEX>
	
	//Clear the pre-parsing flag:
	GPS_MESSAGE_READY = 0;				//Buffer is closed off.
 180:	10 92 ca 00 	sts	0x00CA, r1	; 0x8000ca <__data_end>
 184:	08 95       	ret

00000186 <GPS_enable_stream>:
	
*/
void GPS_enable_stream(void){
	
	//Flush the buffer each time, such that there is a fresh start:
	GPS_flush_buffer();
 186:	0e 94 b6 00 	call	0x16c	; 0x16c <GPS_flush_buffer>
	
	//Also make sure that the parsing flag is reset as well to prevent erroneous behavior:
	GPS_MESSAGE_READY = 0;
 18a:	10 92 ca 00 	sts	0x00CA, r1	; 0x8000ca <__data_end>
	
	//Set receiver-interrupt enable bit, while maintaining register contents:
	UCSRB |= (1 << RXCIE);
 18e:	57 9a       	sbi	0x0a, 7	; 10
 190:	08 95       	ret

00000192 <GPS_parse_data>:
					byte through the linear buffer to extract the relevant NMEA output sentences.
					After the completion of this parsing, the receiver will be enabled again, which
					will clear the buffer and its reception flag, and the cycle will repeat.
			
*/
void GPS_parse_data(void){
 192:	0f 93       	push	r16
 194:	1f 93       	push	r17
 196:	cf 93       	push	r28
	
	//1. Shut down the stream.
	GPS_disable_stream();
 198:	0e 94 7a 00 	call	0xf4	; 0xf4 <GPS_disable_stream>
	
	//2. Reset the MESSAGE_RECEIVED flag
	GPS_MESSAGE_READY = 0;
 19c:	10 92 ca 00 	sts	0x00CA, r1	; 0x8000ca <__data_end>
	
	//3. Look for the sentence type, and confirm RMC:
	//	-The first character should be '$'
	//	-Therefore, GPS_BUFFER[1] is the first sentence-indicating character.
	if( (GPS_BUFFER[1] == 'G')&&
 1a0:	80 91 d1 00 	lds	r24, 0x00D1	; 0x8000d1 <GPS_BUFFER+0x1>
 1a4:	87 34       	cpi	r24, 0x47	; 71
 1a6:	81 f4       	brne	.+32     	; 0x1c8 <GPS_parse_data+0x36>
 1a8:	80 91 d2 00 	lds	r24, 0x00D2	; 0x8000d2 <GPS_BUFFER+0x2>
 1ac:	80 35       	cpi	r24, 0x50	; 80
 1ae:	61 f4       	brne	.+24     	; 0x1c8 <GPS_parse_data+0x36>
		(GPS_BUFFER[2] == 'P')&&
 1b0:	80 91 d3 00 	lds	r24, 0x00D3	; 0x8000d3 <GPS_BUFFER+0x3>
 1b4:	82 35       	cpi	r24, 0x52	; 82
 1b6:	41 f4       	brne	.+16     	; 0x1c8 <GPS_parse_data+0x36>
		(GPS_BUFFER[3] == 'R')&&
 1b8:	80 91 d4 00 	lds	r24, 0x00D4	; 0x8000d4 <GPS_BUFFER+0x4>
 1bc:	8d 34       	cpi	r24, 0x4D	; 77
 1be:	21 f4       	brne	.+8      	; 0x1c8 <GPS_parse_data+0x36>
		(GPS_BUFFER[4] == 'M')&&
 1c0:	80 91 d5 00 	lds	r24, 0x00D5	; 0x8000d5 <GPS_BUFFER+0x5>
 1c4:	83 34       	cpi	r24, 0x43	; 67
 1c6:	09 f0       	breq	.+2      	; 0x1ca <GPS_parse_data+0x38>
 1c8:	ff cf       	rjmp	.-2      	; 0x1c8 <GPS_parse_data+0x36>
		while(1);		//YOU FAILED!
	}
	
	//4. Unpack all of the data between '$' and '*'. Store it on the SYS_GPS object.
		//A. UTC data:
		SYS_GPS.UTC_H = (GPS_BUFFER[RMC_UTC] * 10) + (GPS_BUFFER[RMC_UTC + 1]);	
 1ca:	ad e4       	ldi	r26, 0x4D	; 77
 1cc:	b1 e0       	ldi	r27, 0x01	; 1
 1ce:	e0 ed       	ldi	r30, 0xD0	; 208
 1d0:	f0 e0       	ldi	r31, 0x00	; 0
 1d2:	87 81       	ldd	r24, Z+7	; 0x07
 1d4:	88 0f       	add	r24, r24
 1d6:	98 2f       	mov	r25, r24
 1d8:	99 0f       	add	r25, r25
 1da:	99 0f       	add	r25, r25
 1dc:	89 0f       	add	r24, r25
 1de:	90 85       	ldd	r25, Z+8	; 0x08
 1e0:	89 0f       	add	r24, r25
 1e2:	8c 93       	st	X, r24
		SYS_GPS.UTC_M = ((GPS_BUFFER[RMC_UTC + 2] * 10) + (GPS_BUFFER[RMC_UTC + 3])); 
 1e4:	81 85       	ldd	r24, Z+9	; 0x09
 1e6:	88 0f       	add	r24, r24
 1e8:	98 2f       	mov	r25, r24
 1ea:	99 0f       	add	r25, r25
 1ec:	99 0f       	add	r25, r25
 1ee:	89 0f       	add	r24, r25
 1f0:	92 85       	ldd	r25, Z+10	; 0x0a
 1f2:	89 0f       	add	r24, r25
 1f4:	11 96       	adiw	r26, 0x01	; 1
 1f6:	8c 93       	st	X, r24
 1f8:	11 97       	sbiw	r26, 0x01	; 1
		SYS_GPS.UTC_S = ((GPS_BUFFER[RMC_UTC + 4] * 10) + (GPS_BUFFER[RMC_UTC + 5]));
 1fa:	83 85       	ldd	r24, Z+11	; 0x0b
 1fc:	88 0f       	add	r24, r24
 1fe:	98 2f       	mov	r25, r24
 200:	99 0f       	add	r25, r25
 202:	99 0f       	add	r25, r25
 204:	89 0f       	add	r24, r25
 206:	94 85       	ldd	r25, Z+12	; 0x0c
 208:	89 0f       	add	r24, r25
 20a:	12 96       	adiw	r26, 0x02	; 2
 20c:	8c 93       	st	X, r24
 20e:	12 97       	sbiw	r26, 0x02	; 2
		//B. STATUS:
		SYS_GPS.STATUS = GPS_BUFFER[RMC_STATUS];
 210:	82 89       	ldd	r24, Z+18	; 0x12
 212:	16 96       	adiw	r26, 0x06	; 6
 214:	8c 93       	st	X, r24
 216:	16 97       	sbiw	r26, 0x06	; 6
		//C. LATITUDE:
		SYS_GPS.latitude_H =	(	(GPS_BUFFER[RMC_LAT] * 1000) + 
 218:	44 89       	ldd	r20, Z+20	; 0x14
 21a:	28 ee       	ldi	r18, 0xE8	; 232
 21c:	33 e0       	ldi	r19, 0x03	; 3
 21e:	42 9f       	mul	r20, r18
 220:	c0 01       	movw	r24, r0
 222:	43 9f       	mul	r20, r19
 224:	90 0d       	add	r25, r0
 226:	11 24       	eor	r1, r1
 228:	45 89       	ldd	r20, Z+21	; 0x15
 22a:	c4 e6       	ldi	r28, 0x64	; 100
 22c:	bc 01       	movw	r22, r24
 22e:	c4 9f       	mul	r28, r20
 230:	60 0d       	add	r22, r0
 232:	71 1d       	adc	r23, r1
 234:	11 24       	eor	r1, r1
 236:	96 89       	ldd	r25, Z+22	; 0x16
 238:	89 2f       	mov	r24, r25
 23a:	90 e0       	ldi	r25, 0x00	; 0
 23c:	8c 01       	movw	r16, r24
 23e:	00 0f       	add	r16, r16
 240:	11 1f       	adc	r17, r17
 242:	ac 01       	movw	r20, r24
 244:	44 0f       	add	r20, r20
 246:	55 1f       	adc	r21, r21
 248:	44 0f       	add	r20, r20
 24a:	55 1f       	adc	r21, r21
 24c:	44 0f       	add	r20, r20
 24e:	55 1f       	adc	r21, r21
 250:	c8 01       	movw	r24, r16
 252:	84 0f       	add	r24, r20
 254:	95 1f       	adc	r25, r21
 256:	86 0f       	add	r24, r22
 258:	97 1f       	adc	r25, r23
 25a:	47 89       	ldd	r20, Z+23	; 0x17
 25c:	84 0f       	add	r24, r20
 25e:	91 1d       	adc	r25, r1
 260:	18 96       	adiw	r26, 0x08	; 8
 262:	9c 93       	st	X, r25
 264:	8e 93       	st	-X, r24
 266:	17 97       	sbiw	r26, 0x07	; 7
									(GPS_BUFFER[RMC_LAT + 1] * 100)+
									(GPS_BUFFER[RMC_LAT + 2] * 10)+
									(GPS_BUFFER[RMC_LAT + 3])	);
		SYS_GPS.latitude_L =	(	(GPS_BUFFER[RMC_LAT + 5] * 1000) +
 268:	41 8d       	ldd	r20, Z+25	; 0x19
 26a:	42 9f       	mul	r20, r18
 26c:	c0 01       	movw	r24, r0
 26e:	43 9f       	mul	r20, r19
 270:	90 0d       	add	r25, r0
 272:	11 24       	eor	r1, r1
 274:	42 8d       	ldd	r20, Z+26	; 0x1a
 276:	bc 01       	movw	r22, r24
 278:	c4 9f       	mul	r28, r20
 27a:	60 0d       	add	r22, r0
 27c:	71 1d       	adc	r23, r1
 27e:	11 24       	eor	r1, r1
 280:	93 8d       	ldd	r25, Z+27	; 0x1b
 282:	89 2f       	mov	r24, r25
 284:	90 e0       	ldi	r25, 0x00	; 0
 286:	8c 01       	movw	r16, r24
 288:	00 0f       	add	r16, r16
 28a:	11 1f       	adc	r17, r17
 28c:	ac 01       	movw	r20, r24
 28e:	44 0f       	add	r20, r20
 290:	55 1f       	adc	r21, r21
 292:	44 0f       	add	r20, r20
 294:	55 1f       	adc	r21, r21
 296:	44 0f       	add	r20, r20
 298:	55 1f       	adc	r21, r21
 29a:	c8 01       	movw	r24, r16
 29c:	84 0f       	add	r24, r20
 29e:	95 1f       	adc	r25, r21
 2a0:	86 0f       	add	r24, r22
 2a2:	97 1f       	adc	r25, r23
 2a4:	44 8d       	ldd	r20, Z+28	; 0x1c
 2a6:	84 0f       	add	r24, r20
 2a8:	91 1d       	adc	r25, r1
 2aa:	1a 96       	adiw	r26, 0x0a	; 10
 2ac:	9c 93       	st	X, r25
 2ae:	8e 93       	st	-X, r24
 2b0:	19 97       	sbiw	r26, 0x09	; 9
									(GPS_BUFFER[RMC_LAT + 6] * 100)+
									(GPS_BUFFER[RMC_LAT + 7] * 10)+
									(GPS_BUFFER[RMC_LAT + 8])	);
		SYS_GPS.NS = GPS_BUFFER[RMC_NS];
 2b2:	86 8d       	ldd	r24, Z+30	; 0x1e
 2b4:	1b 96       	adiw	r26, 0x0b	; 11
 2b6:	8c 93       	st	X, r24
 2b8:	1b 97       	sbiw	r26, 0x0b	; 11
		//D. LONGITUDE
		SYS_GPS.longitude_H =	(	(GPS_BUFFER[RMC_LON] * 10000)+
 2ba:	60 a1       	ldd	r22, Z+32	; 0x20
 2bc:	80 e1       	ldi	r24, 0x10	; 16
 2be:	97 e2       	ldi	r25, 0x27	; 39
 2c0:	68 9f       	mul	r22, r24
 2c2:	a0 01       	movw	r20, r0
 2c4:	69 9f       	mul	r22, r25
 2c6:	50 0d       	add	r21, r0
 2c8:	11 24       	eor	r1, r1
 2ca:	61 a1       	ldd	r22, Z+33	; 0x21
 2cc:	62 9f       	mul	r22, r18
 2ce:	c0 01       	movw	r24, r0
 2d0:	63 9f       	mul	r22, r19
 2d2:	90 0d       	add	r25, r0
 2d4:	11 24       	eor	r1, r1
 2d6:	48 0f       	add	r20, r24
 2d8:	59 1f       	adc	r21, r25
 2da:	82 a1       	ldd	r24, Z+34	; 0x22
 2dc:	c8 9f       	mul	r28, r24
 2de:	40 0d       	add	r20, r0
 2e0:	51 1d       	adc	r21, r1
 2e2:	11 24       	eor	r1, r1
 2e4:	83 a1       	ldd	r24, Z+35	; 0x23
 2e6:	90 e0       	ldi	r25, 0x00	; 0
 2e8:	bc 01       	movw	r22, r24
 2ea:	66 0f       	add	r22, r22
 2ec:	77 1f       	adc	r23, r23
 2ee:	88 0f       	add	r24, r24
 2f0:	99 1f       	adc	r25, r25
 2f2:	88 0f       	add	r24, r24
 2f4:	99 1f       	adc	r25, r25
 2f6:	88 0f       	add	r24, r24
 2f8:	99 1f       	adc	r25, r25
 2fa:	86 0f       	add	r24, r22
 2fc:	97 1f       	adc	r25, r23
 2fe:	48 0f       	add	r20, r24
 300:	59 1f       	adc	r21, r25
 302:	84 a1       	ldd	r24, Z+36	; 0x24
 304:	48 0f       	add	r20, r24
 306:	51 1d       	adc	r21, r1
 308:	05 2e       	mov	r0, r21
 30a:	00 0c       	add	r0, r0
 30c:	66 0b       	sbc	r22, r22
 30e:	77 0b       	sbc	r23, r23
 310:	1c 96       	adiw	r26, 0x0c	; 12
 312:	4d 93       	st	X+, r20
 314:	5d 93       	st	X+, r21
 316:	6d 93       	st	X+, r22
 318:	7c 93       	st	X, r23
 31a:	1f 97       	sbiw	r26, 0x0f	; 15
									(GPS_BUFFER[RMC_LON + 1] * 1000)+
									(GPS_BUFFER[RMC_LON + 2] * 100)+
									(GPS_BUFFER[RMC_LON + 3] * 10)+
									(GPS_BUFFER[RMC_LON + 4])	);
		SYS_GPS.longitude_L =	(	(GPS_BUFFER[RMC_LON + 6] * 1000)+
 31c:	46 a1       	ldd	r20, Z+38	; 0x26
 31e:	42 9f       	mul	r20, r18
 320:	c0 01       	movw	r24, r0
 322:	43 9f       	mul	r20, r19
 324:	90 0d       	add	r25, r0
 326:	11 24       	eor	r1, r1
 328:	27 a1       	ldd	r18, Z+39	; 0x27
 32a:	ac 01       	movw	r20, r24
 32c:	c2 9f       	mul	r28, r18
 32e:	40 0d       	add	r20, r0
 330:	51 1d       	adc	r21, r1
 332:	11 24       	eor	r1, r1
 334:	90 a5       	ldd	r25, Z+40	; 0x28
 336:	89 2f       	mov	r24, r25
 338:	90 e0       	ldi	r25, 0x00	; 0
 33a:	bc 01       	movw	r22, r24
 33c:	66 0f       	add	r22, r22
 33e:	77 1f       	adc	r23, r23
 340:	9c 01       	movw	r18, r24
 342:	22 0f       	add	r18, r18
 344:	33 1f       	adc	r19, r19
 346:	22 0f       	add	r18, r18
 348:	33 1f       	adc	r19, r19
 34a:	22 0f       	add	r18, r18
 34c:	33 1f       	adc	r19, r19
 34e:	cb 01       	movw	r24, r22
 350:	82 0f       	add	r24, r18
 352:	93 1f       	adc	r25, r19
 354:	84 0f       	add	r24, r20
 356:	95 1f       	adc	r25, r21
 358:	21 a5       	ldd	r18, Z+41	; 0x29
 35a:	82 0f       	add	r24, r18
 35c:	91 1d       	adc	r25, r1
 35e:	51 96       	adiw	r26, 0x11	; 17
 360:	9c 93       	st	X, r25
 362:	8e 93       	st	-X, r24
 364:	50 97       	sbiw	r26, 0x10	; 16
									(GPS_BUFFER[RMC_LON + 7] * 100)+
									(GPS_BUFFER[RMC_LON + 8] * 10)+
									(GPS_BUFFER[RMC_LON + 9])	);
		SYS_GPS.EW = GPS_BUFFER[RMC_EW];
 366:	83 a5       	ldd	r24, Z+43	; 0x2b
 368:	52 96       	adiw	r26, 0x12	; 18
 36a:	8c 93       	st	X, r24
 36c:	52 97       	sbiw	r26, 0x12	; 18
		//E. SPEED AND COURSE
		SYS_GPS.ground_speed_high = GPS_BUFFER[RMC_SPEED];
 36e:	85 a5       	ldd	r24, Z+45	; 0x2d
 370:	53 96       	adiw	r26, 0x13	; 19
 372:	8c 93       	st	X, r24
 374:	53 97       	sbiw	r26, 0x13	; 19
		SYS_GPS.ground_speed_low = ((GPS_BUFFER[RMC_SPEED + 2] * 10) + (GPS_BUFFER[RMC_SPEED + 3]));
 376:	87 a5       	ldd	r24, Z+47	; 0x2f
 378:	88 0f       	add	r24, r24
 37a:	98 2f       	mov	r25, r24
 37c:	99 0f       	add	r25, r25
 37e:	99 0f       	add	r25, r25
 380:	89 0f       	add	r24, r25
 382:	90 a9       	ldd	r25, Z+48	; 0x30
 384:	89 0f       	add	r24, r25
 386:	54 96       	adiw	r26, 0x14	; 20
 388:	8c 93       	st	X, r24
 38a:	54 97       	sbiw	r26, 0x14	; 20
		SYS_GPS.course_high =	(	(GPS_BUFFER[RMC_COURSE] * 100)+
 38c:	22 a9       	ldd	r18, Z+50	; 0x32
 38e:	83 a9       	ldd	r24, Z+51	; 0x33
 390:	90 e0       	ldi	r25, 0x00	; 0
 392:	ac 01       	movw	r20, r24
 394:	44 0f       	add	r20, r20
 396:	55 1f       	adc	r21, r21
 398:	88 0f       	add	r24, r24
 39a:	99 1f       	adc	r25, r25
 39c:	88 0f       	add	r24, r24
 39e:	99 1f       	adc	r25, r25
 3a0:	88 0f       	add	r24, r24
 3a2:	99 1f       	adc	r25, r25
 3a4:	84 0f       	add	r24, r20
 3a6:	95 1f       	adc	r25, r21
 3a8:	c2 9f       	mul	r28, r18
 3aa:	80 0d       	add	r24, r0
 3ac:	91 1d       	adc	r25, r1
 3ae:	11 24       	eor	r1, r1
 3b0:	24 a9       	ldd	r18, Z+52	; 0x34
 3b2:	82 0f       	add	r24, r18
 3b4:	91 1d       	adc	r25, r1
 3b6:	56 96       	adiw	r26, 0x16	; 22
 3b8:	9c 93       	st	X, r25
 3ba:	8e 93       	st	-X, r24
 3bc:	55 97       	sbiw	r26, 0x15	; 21
									(GPS_BUFFER[RMC_COURSE + 1] * 10)+
									(GPS_BUFFER[RMC_COURSE + 2])	);
		SYS_GPS.course_low = ((GPS_BUFFER[RMC_COURSE + 4] * 10) + (GPS_BUFFER[RMC_COURSE + 5]));
 3be:	86 a9       	ldd	r24, Z+54	; 0x36
 3c0:	88 0f       	add	r24, r24
 3c2:	98 2f       	mov	r25, r24
 3c4:	99 0f       	add	r25, r25
 3c6:	99 0f       	add	r25, r25
 3c8:	89 0f       	add	r24, r25
 3ca:	97 a9       	ldd	r25, Z+55	; 0x37
 3cc:	89 0f       	add	r24, r25
 3ce:	57 96       	adiw	r26, 0x17	; 23
 3d0:	8c 93       	st	X, r24
 3d2:	57 97       	sbiw	r26, 0x17	; 23
		//F. DATE
		SYS_GPS.UTC_DAY =	((GPS_BUFFER[RMC_DATE] * 10) + (GPS_BUFFER[RMC_DATE + 1]));
 3d4:	81 ad       	ldd	r24, Z+57	; 0x39
 3d6:	88 0f       	add	r24, r24
 3d8:	98 2f       	mov	r25, r24
 3da:	99 0f       	add	r25, r25
 3dc:	99 0f       	add	r25, r25
 3de:	89 0f       	add	r24, r25
 3e0:	92 ad       	ldd	r25, Z+58	; 0x3a
 3e2:	89 0f       	add	r24, r25
 3e4:	13 96       	adiw	r26, 0x03	; 3
 3e6:	8c 93       	st	X, r24
 3e8:	13 97       	sbiw	r26, 0x03	; 3
		SYS_GPS.UTC_MONTH = ((GPS_BUFFER[RMC_DATE + 2] * 10) + (GPS_BUFFER[RMC_DATE + 3]));
 3ea:	83 ad       	ldd	r24, Z+59	; 0x3b
 3ec:	88 0f       	add	r24, r24
 3ee:	98 2f       	mov	r25, r24
 3f0:	99 0f       	add	r25, r25
 3f2:	99 0f       	add	r25, r25
 3f4:	89 0f       	add	r24, r25
 3f6:	94 ad       	ldd	r25, Z+60	; 0x3c
 3f8:	89 0f       	add	r24, r25
 3fa:	14 96       	adiw	r26, 0x04	; 4
 3fc:	8c 93       	st	X, r24
 3fe:	14 97       	sbiw	r26, 0x04	; 4
		SYS_GPS.UTC_YEAR =	((GPS_BUFFER[RMC_DATE + 4] * 10) + (GPS_BUFFER[RMC_DATE + 5]));
 400:	85 ad       	ldd	r24, Z+61	; 0x3d
 402:	88 0f       	add	r24, r24
 404:	98 2f       	mov	r25, r24
 406:	99 0f       	add	r25, r25
 408:	99 0f       	add	r25, r25
 40a:	89 0f       	add	r24, r25
 40c:	96 ad       	ldd	r25, Z+62	; 0x3e
 40e:	89 0f       	add	r24, r25
 410:	15 96       	adiw	r26, 0x05	; 5
 412:	8c 93       	st	X, r24
	
	//?. Enable stream, thereby flushing the buffer of all its contents.
	GPS_enable_stream();
 414:	0e 94 c3 00 	call	0x186	; 0x186 <GPS_enable_stream>
	
};
 418:	cf 91       	pop	r28
 41a:	1f 91       	pop	r17
 41c:	0f 91       	pop	r16
 41e:	08 95       	ret

00000420 <SD_assert>:
	
	//Read in the status register to clear it:
	clear_byte = SPSR;
	
	//Write a byte to the data register to prepare it:
	SPDR = clear_byte;
 420:	8b b3       	in	r24, 0x1b	; 27
 422:	1b ba       	out	0x1b, r1	; 27
 424:	08 95       	ret

00000426 <SD_SPI_send_byte>:
////////////////////////////////////////////////////////////////////////////////////////////////////
void SD_SPI_send_byte(char byte){
	
	//DO NOT assert the device. 
	//Simply write the byte and wait until transmission has concluded:
	SPDR = byte;
 426:	8f b9       	out	0x0f, r24	; 15
	//Wait for transmission termination:
	while(!(SPSR & (1 << SPIF)));
 428:	77 9b       	sbis	0x0e, 7	; 14
 42a:	fe cf       	rjmp	.-4      	; 0x428 <SD_SPI_send_byte+0x2>
	
}
 42c:	08 95       	ret

0000042e <SD_SPI_send_command>:
////////////////////////////////////////////////////////////////////////////////////////////////////
void SD_SPI_send_command(uint8_t command, uint32_t arguments, uint8_t CRC){
 42e:	ff 92       	push	r15
 430:	0f 93       	push	r16
 432:	1f 93       	push	r17
 434:	cf 93       	push	r28
 436:	df 93       	push	r29
 438:	d4 2f       	mov	r29, r20
 43a:	15 2f       	mov	r17, r21
 43c:	06 2f       	mov	r16, r22
 43e:	f7 2e       	mov	r15, r23
 440:	c2 2f       	mov	r28, r18
	
	//Send command:
	SD_SPI_send_byte(command);
 442:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
	//Send arguments MSB first:
	SD_SPI_send_byte((char)(arguments >> 24));
 446:	8f 2d       	mov	r24, r15
 448:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
	SD_SPI_send_byte((char)(arguments >> 16));
 44c:	80 2f       	mov	r24, r16
 44e:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
	SD_SPI_send_byte((char)(arguments >> 8));
 452:	81 2f       	mov	r24, r17
 454:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
	SD_SPI_send_byte((char)(arguments));
 458:	8d 2f       	mov	r24, r29
 45a:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
	//Send the CRC:
	SD_SPI_send_byte(CRC);
 45e:	8c 2f       	mov	r24, r28
 460:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
	
}
 464:	df 91       	pop	r29
 466:	cf 91       	pop	r28
 468:	1f 91       	pop	r17
 46a:	0f 91       	pop	r16
 46c:	ff 90       	pop	r15
 46e:	08 95       	ret

00000470 <SD_init_card>:
////////////////////////////////////////////////////////////////////////////////////////////////////
void SD_init_card(void){
 470:	cf 93       	push	r28
	
	//Assert the device and hold:
	PORTA &= !(1 << SD_SLAVE_PIN);
 472:	8b b3       	in	r24, 0x1b	; 27
 474:	1b ba       	out	0x1b, r1	; 27
 476:	8a e0       	ldi	r24, 0x0A	; 10
 478:	90 e0       	ldi	r25, 0x00	; 0
	
	//Send ten dummy bytes:
	for(int bytes = 0; bytes < 10; bytes++){

		//Dummy bytes for SD are always 0xFF:
		SPDR = 0xFF;
 47a:	2f ef       	ldi	r18, 0xFF	; 255
 47c:	2f b9       	out	0x0f, r18	; 15
		//Wait for transmission:
		while(!(SPSR & (1 << SPIF)));
 47e:	77 9b       	sbis	0x0e, 7	; 14
 480:	fe cf       	rjmp	.-4      	; 0x47e <SD_init_card+0xe>
 482:	01 97       	sbiw	r24, 0x01	; 1
	
	//Assert the device and hold:
	PORTA &= !(1 << SD_SLAVE_PIN);
	
	//Send ten dummy bytes:
	for(int bytes = 0; bytes < 10; bytes++){
 484:	d9 f7       	brne	.-10     	; 0x47c <SD_init_card+0xc>
		while(!(SPSR & (1 << SPIF)));
	}
	
	/* INITIALIZATION PROCESS */
	//1. COMMAND 1: CMD0
		SD_SPI_send_byte(0x40);
 486:	80 e4       	ldi	r24, 0x40	; 64
 488:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
		for(char i = 0; i < 4; i++){
			SD_SPI_send_byte(0x00);
 48c:	80 e0       	ldi	r24, 0x00	; 0
 48e:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
 492:	80 e0       	ldi	r24, 0x00	; 0
 494:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
 498:	80 e0       	ldi	r24, 0x00	; 0
 49a:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
 49e:	80 e0       	ldi	r24, 0x00	; 0
 4a0:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
		}
		//CRC byte:
		SD_SPI_send_byte(0x95);
 4a4:	85 e9       	ldi	r24, 0x95	; 149
 4a6:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
		//Check receiver constantly for the IDLE response:
		char helper;
		while(1){
			//Read data register
			helper = SPDR;
 4aa:	8f b1       	in	r24, 0x0f	; 15
			if(helper == 0x01){break;}
 4ac:	81 30       	cpi	r24, 0x01	; 1
 4ae:	31 f0       	breq	.+12     	; 0x4bc <SD_init_card+0x4c>
			//Generate another 8 pulses:
			SD_SPI_send_byte(0xFF);
 4b0:	8f ef       	ldi	r24, 0xFF	; 255
 4b2:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
		SD_SPI_send_byte(0x95);
		//Check receiver constantly for the IDLE response:
		char helper;
		while(1){
			//Read data register
			helper = SPDR;
 4b6:	8f b1       	in	r24, 0x0f	; 15
			if(helper == 0x01){break;}
 4b8:	81 30       	cpi	r24, 0x01	; 1
 4ba:	d1 f7       	brne	.-12     	; 0x4b0 <SD_init_card+0x40>
			SD_SPI_send_byte(0xFF);
		}
	//2. COMMAND 2: CMD8
		//This is the voltage range command.
		//We are using it to determine what generation card ours is.
		SD_SPI_send_command(0x48, 0x000001AA, 0x87);
 4bc:	27 e8       	ldi	r18, 0x87	; 135
 4be:	4a ea       	ldi	r20, 0xAA	; 170
 4c0:	51 e0       	ldi	r21, 0x01	; 1
 4c2:	60 e0       	ldi	r22, 0x00	; 0
 4c4:	70 e0       	ldi	r23, 0x00	; 0
 4c6:	88 e4       	ldi	r24, 0x48	; 72
 4c8:	0e 94 17 02 	call	0x42e	; 0x42e <SD_SPI_send_command>
		//Wait for either GEN1 (0x05) or GEN2 (0x01)
		while(1){
			helper = SPDR;
 4cc:	8f b1       	in	r24, 0x0f	; 15
			if(helper == 0x05){
 4ce:	85 30       	cpi	r24, 0x05	; 5
 4d0:	19 f0       	breq	.+6      	; 0x4d8 <SD_init_card+0x68>
				//GEN1
				Card_Type = '*';
				break;
			}
			else if(helper == 0x01){
 4d2:	81 30       	cpi	r24, 0x01	; 1
 4d4:	59 f4       	brne	.+22     	; 0x4ec <SD_init_card+0x7c>
 4d6:	06 c0       	rjmp	.+12     	; 0x4e4 <SD_init_card+0x74>
		//Wait for either GEN1 (0x05) or GEN2 (0x01)
		while(1){
			helper = SPDR;
			if(helper == 0x05){
				//GEN1
				Card_Type = '*';
 4d8:	8a e2       	ldi	r24, 0x2A	; 42
 4da:	80 93 65 01 	sts	0x0165, r24	; 0x800165 <Card_Type>
				break;
 4de:	23 c0       	rjmp	.+70     	; 0x526 <SD_init_card+0xb6>
			}
			else if(helper == 0x01){
 4e0:	81 30       	cpi	r24, 0x01	; 1
 4e2:	21 f4       	brne	.+8      	; 0x4ec <SD_init_card+0x7c>
				//GEN2
				Card_Type = '&';
 4e4:	86 e2       	ldi	r24, 0x26	; 38
 4e6:	80 93 65 01 	sts	0x0165, r24	; 0x800165 <Card_Type>
				break;
 4ea:	1d c0       	rjmp	.+58     	; 0x526 <SD_init_card+0xb6>
			}
			SD_SPI_send_byte(0x00);
 4ec:	80 e0       	ldi	r24, 0x00	; 0
 4ee:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
		//This is the voltage range command.
		//We are using it to determine what generation card ours is.
		SD_SPI_send_command(0x48, 0x000001AA, 0x87);
		//Wait for either GEN1 (0x05) or GEN2 (0x01)
		while(1){
			helper = SPDR;
 4f2:	8f b1       	in	r24, 0x0f	; 15
			if(helper == 0x05){
 4f4:	85 30       	cpi	r24, 0x05	; 5
 4f6:	a1 f7       	brne	.-24     	; 0x4e0 <SD_init_card+0x70>
 4f8:	ef cf       	rjmp	.-34     	; 0x4d8 <SD_init_card+0x68>
			}
			SD_SPI_send_byte(0x00);
		}
		//Send a few dummy bytes to terminate the command:
		for(char i = 0; i < 5; i++){
			SD_SPI_send_byte(0xFF);
 4fa:	8f ef       	ldi	r24, 0xFF	; 255
 4fc:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
 500:	c1 50       	subi	r28, 0x01	; 1
				break;
			}
			SD_SPI_send_byte(0x00);
		}
		//Send a few dummy bytes to terminate the command:
		for(char i = 0; i < 5; i++){
 502:	d9 f7       	brne	.-10     	; 0x4fa <SD_init_card+0x8a>
			SD_SPI_send_byte(0xFF);
		}
	//3. COMMAND 3: CMD1
		//This command begins initialization, and has no arguments:
		SD_SPI_send_command(0x61, 0x00000000, 0x00);
 504:	20 e0       	ldi	r18, 0x00	; 0
 506:	40 e0       	ldi	r20, 0x00	; 0
 508:	50 e0       	ldi	r21, 0x00	; 0
 50a:	ba 01       	movw	r22, r20
 50c:	81 e6       	ldi	r24, 0x61	; 97
 50e:	0e 94 17 02 	call	0x42e	; 0x42e <SD_SPI_send_command>
		//Wait for "0x00":
		while(1){
			helper = SPDR;
 512:	8f b1       	in	r24, 0x0f	; 15
			if(helper == 0x00){
 514:	88 23       	and	r24, r24
 516:	49 f0       	breq	.+18     	; 0x52a <SD_init_card+0xba>
				break;
			}
			SD_SPI_send_byte(0x00);
 518:	80 e0       	ldi	r24, 0x00	; 0
 51a:	0e 94 13 02 	call	0x426	; 0x426 <SD_SPI_send_byte>
	//3. COMMAND 3: CMD1
		//This command begins initialization, and has no arguments:
		SD_SPI_send_command(0x61, 0x00000000, 0x00);
		//Wait for "0x00":
		while(1){
			helper = SPDR;
 51e:	8f b1       	in	r24, 0x0f	; 15
			if(helper == 0x00){
 520:	81 11       	cpse	r24, r1
 522:	fa cf       	rjmp	.-12     	; 0x518 <SD_init_card+0xa8>
 524:	02 c0       	rjmp	.+4      	; 0x52a <SD_init_card+0xba>
}
////////////////////////////////////////////////////////////////////////////////////////////////////
void SD_init_card(void){
	
	//Assert the device and hold:
	PORTA &= !(1 << SD_SLAVE_PIN);
 526:	c5 e0       	ldi	r28, 0x05	; 5
 528:	e8 cf       	rjmp	.-48     	; 0x4fa <SD_init_card+0x8a>
	
	//This is just to use a breakpoint, please get rid of it after testing:
	helper = '*';
	
	//END OF INITIALIZATION
}
 52a:	cf 91       	pop	r28
 52c:	08 95       	ret

0000052e <__vector_11>:
//								INTERRUPTS    											          //
////////////////////////////////////////////////////////////////////////////////////////////////////
/* KEYPAD INTERRUPT FOR FSM */

/* GPS INTERRUPT FOR PARSING */
ISR(USARTRXC_vect){
 52e:	1f 92       	push	r1
 530:	0f 92       	push	r0
 532:	0f b6       	in	r0, 0x3f	; 63
 534:	0f 92       	push	r0
 536:	11 24       	eor	r1, r1
 538:	2f 93       	push	r18
 53a:	3f 93       	push	r19
 53c:	4f 93       	push	r20
 53e:	5f 93       	push	r21
 540:	6f 93       	push	r22
 542:	7f 93       	push	r23
 544:	8f 93       	push	r24
 546:	9f 93       	push	r25
 548:	af 93       	push	r26
 54a:	bf 93       	push	r27
 54c:	cf 93       	push	r28
 54e:	ef 93       	push	r30
 550:	ff 93       	push	r31
	
	//Receive the byte to empty out the buffer, then operate on it:
	char vector_data = GPS_receive_byte();
 552:	0e 94 b2 00 	call	0x164	; 0x164 <GPS_receive_byte>
 556:	c8 2f       	mov	r28, r24
	
	//Always start with an overflow check:
	// -Since the sentence length won't exceed 120, we should worry if it gets to 121.
	// -Should this happen, a hard reset is necessary, so we'll do exactly that.
	if(GPS_BUFFER_INDEX > 120){GPS_flush_buffer();}
 558:	80 91 cb 00 	lds	r24, 0x00CB	; 0x8000cb <GPS_BUFFER_INDEX>
 55c:	89 37       	cpi	r24, 0x79	; 121
 55e:	10 f0       	brcs	.+4      	; 0x564 <__vector_11+0x36>
 560:	0e 94 b6 00 	call	0x16c	; 0x16c <GPS_flush_buffer>
	
	//Filter out whether or not this data can be transferred to the buffer:
	//	-This requires either that the received character is '$' or GPS_MESSAGE_READY = 1;
	if(vector_data == '$'){
 564:	c4 32       	cpi	r28, 0x24	; 36
 566:	49 f4       	brne	.+18     	; 0x57a <__vector_11+0x4c>
		GPS_MESSAGE_READY = 1;
 568:	81 e0       	ldi	r24, 0x01	; 1
 56a:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__data_end>
		//These assignments help with buffering alignment.
		GPS_BUFFER[0] = '$';
 56e:	94 e2       	ldi	r25, 0x24	; 36
 570:	90 93 d0 00 	sts	0x00D0, r25	; 0x8000d0 <GPS_BUFFER>
		GPS_BUFFER_INDEX = 1;
 574:	80 93 cb 00 	sts	0x00CB, r24	; 0x8000cb <GPS_BUFFER_INDEX>
 578:	13 c0       	rjmp	.+38     	; 0x5a0 <__vector_11+0x72>
	}
	//If the character received is instead a terminator, begin the parsing!
	else if(vector_data == '*'){
 57a:	ca 32       	cpi	r28, 0x2A	; 42
 57c:	19 f4       	brne	.+6      	; 0x584 <__vector_11+0x56>
		GPS_parse_data();
 57e:	0e 94 c9 00 	call	0x192	; 0x192 <GPS_parse_data>
 582:	0e c0       	rjmp	.+28     	; 0x5a0 <__vector_11+0x72>
	}
	//If neither character was detected, but '$' appeared previously, then just buffer the characters:
	else if(GPS_MESSAGE_READY){
 584:	80 91 ca 00 	lds	r24, 0x00CA	; 0x8000ca <__data_end>
 588:	88 23       	and	r24, r24
 58a:	51 f0       	breq	.+20     	; 0x5a0 <__vector_11+0x72>
		GPS_BUFFER[GPS_BUFFER_INDEX] = vector_data;
 58c:	80 91 cb 00 	lds	r24, 0x00CB	; 0x8000cb <GPS_BUFFER_INDEX>
 590:	e8 2f       	mov	r30, r24
 592:	f0 e0       	ldi	r31, 0x00	; 0
 594:	e0 53       	subi	r30, 0x30	; 48
 596:	ff 4f       	sbci	r31, 0xFF	; 255
 598:	c0 83       	st	Z, r28
		GPS_BUFFER_INDEX++;
 59a:	8f 5f       	subi	r24, 0xFF	; 255
 59c:	80 93 cb 00 	sts	0x00CB, r24	; 0x8000cb <GPS_BUFFER_INDEX>
	}
	
}
 5a0:	ff 91       	pop	r31
 5a2:	ef 91       	pop	r30
 5a4:	cf 91       	pop	r28
 5a6:	bf 91       	pop	r27
 5a8:	af 91       	pop	r26
 5aa:	9f 91       	pop	r25
 5ac:	8f 91       	pop	r24
 5ae:	7f 91       	pop	r23
 5b0:	6f 91       	pop	r22
 5b2:	5f 91       	pop	r21
 5b4:	4f 91       	pop	r20
 5b6:	3f 91       	pop	r19
 5b8:	2f 91       	pop	r18
 5ba:	0f 90       	pop	r0
 5bc:	0f be       	out	0x3f, r0	; 63
 5be:	0f 90       	pop	r0
 5c0:	1f 90       	pop	r1
 5c2:	18 95       	reti

000005c4 <main>:
	///////////////
	//   SETUP   //
	///////////////
	
	/* PORTS */
	DDRA = 0xFF;	//Port A is not currently used, but may assert slaves in the future.
 5c4:	8f ef       	ldi	r24, 0xFF	; 255
 5c6:	8a bb       	out	0x1a, r24	; 26
	PORTA = 0x00;	
 5c8:	1b ba       	out	0x1b, r1	; 27
	
	DDRB = 0xCD;	//Port B contains:
 5ca:	8d ec       	ldi	r24, 0xCD	; 205
 5cc:	87 bb       	out	0x17, r24	; 23
	PORTB = 0x32;	// SPI, INT2 ( Pin 3 ), connection to LCD ( data out ).
 5ce:	82 e3       	ldi	r24, 0x32	; 50
 5d0:	88 bb       	out	0x18, r24	; 24
	
	DDRC = 0x00;	//Port C contains:
 5d2:	14 ba       	out	0x14, r1	; 20
	PORTC = 0x00;	// JTAG interface; this renders some of the pins unusable as I/O.
 5d4:	15 ba       	out	0x15, r1	; 21
	
	DDRD = 0x4F;	//Port D contains:
 5d6:	8f e4       	ldi	r24, 0x4F	; 79
 5d8:	81 bb       	out	0x11, r24	; 17
	PORTD = 0x80;	// USART, INT0, INT1, buzzer driver pin
 5da:	80 e8       	ldi	r24, 0x80	; 128
 5dc:	82 bb       	out	0x12, r24	; 18
	
	/* RECOVERY */
	//Recovery program is currently defined in the EEPROM driver.
	EEPROM_enable();
 5de:	0e 94 4e 00 	call	0x9c	; 0x9c <EEPROM_enable>
	//This recovery program must have two components!
	//EEPROM_recovery(); AND SD_recovery(); which is not yet available!
	EEPROM_recovery();				//Reacquire old persistent information.
 5e2:	0e 94 5a 00 	call	0xb4	; 0xb4 <EEPROM_recovery>
	//SD Card must be initialized here as well, and erroneous data must be purged:
	SD_assert();
 5e6:	0e 94 10 02 	call	0x420	; 0x420 <SD_assert>
	//Initialize the SD card: {Be sure to look into the function when single-stepping}
	SD_init_card();
 5ea:	0e 94 38 02 	call	0x470	; 0x470 <SD_init_card>
	/* INTERRUPTS */
	//Must enable global interrupts to use GPS hardware.
	
	/* GPS */
	//Initialize communication, then configure MTK3339 firmware, then open up.
	GPS_BUFFER_INDEX = 0;			//Begin at start of data buffer.
 5ee:	10 92 cb 00 	sts	0x00CB, r1	; 0x8000cb <GPS_BUFFER_INDEX>
	GPS_MESSAGE_READY= 0;			//Buffer will begin to fill normally.
 5f2:	10 92 ca 00 	sts	0x00CA, r1	; 0x8000ca <__data_end>
	GPS_init_USART(9600);
 5f6:	80 e8       	ldi	r24, 0x80	; 128
 5f8:	95 e2       	ldi	r25, 0x25	; 37
 5fa:	0e 94 73 00 	call	0xe6	; 0xe6 <GPS_init_USART>
	GPS_configure_firmware();
 5fe:	0e 94 81 00 	call	0x102	; 0x102 <GPS_configure_firmware>
	//Consider actually enabling the stream.
	GPS_disable_stream();
 602:	0e 94 7a 00 	call	0xf4	; 0xf4 <GPS_disable_stream>

	
	/* TIMERS/BUZZER */
	//Initialize the buzzer:
	init_buzzer();
 606:	0e 94 49 00 	call	0x92	; 0x92 <init_buzzer>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 60a:	82 e0       	ldi	r24, 0x02	; 2
 60c:	8a 95       	dec	r24
 60e:	f1 f7       	brne	.-4      	; 0x60c <main+0x48>
 610:	00 c0       	rjmp	.+0      	; 0x612 <main+0x4e>
		
	//Dormant program loop for testing.
    while (1) 
    {
		_delay_us(0.5);
		PORTB &= ~(1<<0);
 612:	c0 98       	cbi	0x18, 0	; 24
 614:	fa cf       	rjmp	.-12     	; 0x60a <main+0x46>

00000616 <_exit>:
 616:	f8 94       	cli

00000618 <__stop_program>:
 618:	ff cf       	rjmp	.-2      	; 0x618 <__stop_program>
